<!DOCTYPE html>
<html xmlns = "http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8" />
<title>Parabola</title>
</head>
<style type="text/css" media="Screen">
a{text-decoration:none;color:blue;}
a:hover{text-decoration:underline;}
a:visited{color:blue;}
li{list-style-type:none;cursor:pointer;padding-left: 7px;padding-right: 27px;}
//li{list-style-type:none;cursor:pointer;padding-left: 7px;outline: 1px solid black}
i{padding: 7px;outline: 1px solid black;cursor:pointer;}
//ul{margin-right:auto;widthq:100%}
//td{cursor:pointer;}
sub{font-size:0.83rem;}
sup{font-size:0.83rem;}
//ul{display:flex;flex-direction:column-reverse;}
</style>
<body style="font-family:Arial;white-space:pre;line-height:0;"
><span id="listc" style="float:left;line-height:0.9;position: absolute;top:0;bottom:0;padding-bottom:32px;left:10px;right:0;overflow-x:overlay;overflow-y:auto;flex-direction:column-reverse;" onmousedown0="return false"><br/><br/></span><div id="xs" style="position:fixed;border:1px solid #cccccc;border-radius:5px;padding:5px 5px 5px 15px;background:white;line-height:1.5;";
hidden></div><script
>'use strict'

function getw(n)
{
w=Math.floor(1000/n);
if(w>maxw)
   w=maxw;
else if(w<minw)
   w=minw;
}

function setar(n)
{
tar=[];
car=[];
mar=[];
addfn1(n);
car.push(0);
mar.push(0);
for(let e=1;e<n;e++)
   {car.push(0);
   mar.push(n%e);
   }
mar.push(0);
if(fn[0].length>n)
   {maxc=fn[0][n];
   maxcz=fn[1][n];
   tar.push(0);
   car[0]++;   
   for(let e=1;e<n;e++)
      {let i=fn[7][e]%n;
      tar.push(i);
      car[i]++;
      }
   }
else
   {maxc=0;
   maxcz=0;
   tar.push(0);
   car[0]++;
   for(let e=1;e<n;e++)
      {let i=fn[7][e]%n;
      tar.push(i);
      car[i]++;
      if(i&&car[i]>maxcz)
         maxcz++;
      maxc=Math.max(car[0],maxcz);
      }
   }
}

function addgraph(s,n,w,fsize,g)
{
let x,y,x0,y0;
let gc=document.createElement('g');
gc.setAttribute('id','gc'+g);
gc.setAttribute('opacity',vgr[g]?1:vgrh);
let grc=document.createElement('g');
grc.setAttribute('id','grc'+g);
grc.setAttribute('height',300);
grc.setAttribute('opacity',vgr[g]?1:0);
for(let e=0;e<=n+(grx[g]?0:1);e++)
   {let w1=e>n||e==0?maxw:w;
   if(e)
      {
      x0=e>1?x:0.25*w1;
      y0=e>1?y:n*w+(1+g%3)*maxw;
      }
   //if(graph!=7||wmode||!e||e>=pwidth||n<pwidth)
   if((graph<5||!e||e>=ms)&&(graph!=7||(wmode>1?!mar[e]:!pwidth||n<pwidth||!(e%pwidth))))
   {
   x=e?(e-0.5)*w1:1.5*w1;
   //y=e?(n-(graph==4?-0.5:0.5)-(graph!=7||(!pwidth&&!wmode)||n<pwidth?fn[g][e]:wmode?fnw[g-15][n][e-1]:fnw[g-15][e][pwidth-1])-(graph==3||graph==5||graph==6||graph==7||graph==8||graph==9?tu:0))*w1:n*w+(1+g%3)*w1;
   y=e?(n-(graph==4?-0.5:0.5)-(graph!=7?fn[g][e]:wmode>1?fnw[g-15][n][e]:!pwidth||n<pwidth?fn[g][e]:fnw[g-15][e][wmode?e/pwidth:pwidth])-(graph==3||graph==5||graph==6||graph==7||graph==8||graph==9?tu:0))*w1:n*w+(1+g%3)*w1;
   if(e>n)
      {grx[g]=document.createElement('g');
      x=w1/4;
      y=w1/4;
      }
   let m=document.createElement(fgr[g]);
   if(g==0||g==3||g==6||g==9||g==12||g==15||g==18||g==21)
      {m.setAttribute('y',y-w1/4);
      m.setAttribute('x',x-w1/4);
      m.setAttribute('width',w1/2);
      m.setAttribute('height',w1/2);
      }
   else if(g==1||g==4||g==10||g==13||g==16||g==19||g==22)
      {m.setAttribute('points',(x-w1/6)+','+y+' '+x+','+(y-w1/4)+' '+(x+w1/6)+','+y+' '+x+','+(y+w1/4));
      }
   else if(g==2||g==5||g==11||g==14||g==17||g==20||g==23)
      {m.setAttribute('cx',x);
      m.setAttribute('cy',y);
      m.setAttribute('r',w1/8);
      }
   m.style.fill=cgr[g];
   //
   if(e>n)
      grx[g].appendChild(m);
   else if(e)
      grc.appendChild(m);
   else
   	gc.appendChild(m);
   }
   //if(e&&e<=n)
   //if(e&&e<=n&&(graph!=7||wmode||e==1||e>pwidth||n<pwidth))
   if(e==1||y0<n*w)
   if(e<=n&&(graph<5||e==1||e>ms)&&(graph!=7||(wmode>1?!mar[e]:!pwidth||n<pwidth||!(e%pwidth))))
      {if(e==1)
         w1=maxw;
      let x1=(e==1)?2.75*w1:x;
      let y1=(e==1)?y0:y;
      let li=document.createElement('line');
      li.setAttribute('x1',x0);
      li.setAttribute('y1',y0);
      li.setAttribute('x2',x1);
      li.setAttribute('y2',y1);
      li.setAttribute('stroke',cgr[g]);
      li.setAttribute('stroke-width',w1/wgr[g]);
      if(e==1)
         gc.appendChild(li);
      else
   	   grc.appendChild(li);
      }
   }
let t=document.createElement('text');
t.setAttribute('x',3*maxw);
t.setAttribute('y',n*w+(1+g%3)*maxw+maxfsize/2);
//t.setAttribute('font-size',fsize+'px');
t.innerHTML=tgr[g];
gc.appendChild(t);
s.appendChild(grc);
s.appendChild(gc);
let grect=document.createElement('rect');
grect.setAttribute('id','grect'+g);
grect.setAttribute('y',n*w+(0.75+g%3)*maxw);
grect.setAttribute('x',0);
grect.setAttribute('width',maxw*3);
grect.setAttribute('height',maxw/2);
grect.setAttribute('opacity',0);
grect.style.cursor='pointer';
grect.setAttribute('onclick','grectclick('+g+')');
grect.setAttribute('onmousemove','setgm('+g+')');
grect.setAttribute('onmouseleave','setgm(-1)');
s.appendChild(grect);
}

function setgm(g)
{gm=g;
}

function addtable(n)
{
if(graph==1||graph==7)
   setar(n);
let to=1.5;
getw(n);
tu=Math.floor(n/2+(n%2?-0.5:0.5));

let fsize=Math.floor(w*0.5);
if(fsize>maxfsize)
   fsize=maxfsize;

listc.lastChild.remove();
listc.lastChild.remove();

let t=document.createElement('span');
t.border=2;
t.cellPadding=0;
t.style.textAlign='center';
t.style.borderSpacing='0';
t.style.width=w*n+'px';
t.style.height=w*n+'px';
t.style.border='none';
t.id='tc';

t.innerHTML+='<span id="th" style="font-size:32px"><br/>N = '+n+'</span><br/><br/>';

let d=document.createElement('span');

      let s=document.createElement('svg');
      s.setAttribute('id','svg');
      s.setAttribute('width',Math.max(357,w*(n+5)));
      s.setAttribute('height',w*n+(graph==1?w:maxw)*((graph==1?maxc:graph==4?0:2)+to));

      let e;
      let re=document.createElement('rect');
      re.setAttribute('id','mh');
      e=(Math.floor((mousey+listc.scrollTop-68)/w))*w;
      if(e>=w*n||e<0)
         e=-1000000;
      re.setAttribute('y',e);
      re.setAttribute('x',0);
      re.setAttribute('width',w*n);
      re.setAttribute('height',w);
      re.setAttribute('opacity',mhvh);
      re.style.fill='#ffff00';
      s.appendChild(re);
      
      re=document.createElement('rect');
      re.setAttribute('id','mv');
      re.setAttribute('y',0);
      e=(Math.floor((mousex+listc.scrollLeft-10)/w))*w;
      if(e>=w*n||e<0)
         e=-1000000;
      re.setAttribute('x',e);
      re.setAttribute('width',w);
      re.setAttribute('height',w*n);
      re.setAttribute('opacity',mhvh);
      re.style.fill='#ffff00';
      s.appendChild(re);
      
      let i=gro[graph];
      while(grg[i]==graph)
         {
         re=document.createElement('rect');
         re.setAttribute('id','hg'+i);
         re.setAttribute('y',fn[i][0]);
         re.setAttribute('x',0);
         re.setAttribute('width',w*n);
         re.setAttribute('height',w);
         re.setAttribute('opacity',vgr[i]?hgv:0);
         re.style.fill=cgr[i];
         s.appendChild(re);
         i++;
         }
      
      if(graph!=4)
      {let g=document.createElement('g');
      g.setAttribute('id','rc');

      re=document.createElement('rect');
      re.setAttribute('id','zerostring');
      re.setAttribute('y',((n-1-(graph==1?mode:graph==2?0:1)*tu)%n)*w);
      re.setAttribute('x',0);
      re.setAttribute('width',w*n);
      re.setAttribute('height',w);
      re.setAttribute('opacity',0.1);
      g.appendChild(re);
      
      if(graph==2)
      for(e=1;e<=n;e++)
      {addfn2(n);
      addfn5(n);
      if(fn[8][e])
      {re=document.createElement('rect');
      re.setAttribute('y',0);
      re.setAttribute('x',(e-1)*w);
      re.setAttribute('width',w);
      re.setAttribute('height',n*w);
      re.setAttribute('opacity',0.05);
      g.appendChild(re);}}

      if(graph==1)
      {
      for(e=0;e<n;e++)
      {re=document.createElement('rect');
      re.setAttribute('id','r'+e);
      re.setAttribute('y',((n*2-e-1-mode*tu)%n)*w);
      re.setAttribute('x',tar[e]*w);
      re.setAttribute('width',w);
      re.setAttribute('height',w);
      re.style.fill='#ff0000';
      g.appendChild(re);

      re=document.createElement('rect');
      re.setAttribute('id','g'+e);
      re.setAttribute('x',e*w);
      re.setAttribute('y',w*(n+maxc-car[e]+to));
      re.setAttribute('width',w-1);
      re.setAttribute('height',w*car[e]);
      re.style.fill='#a0d7d7';
      g.appendChild(re);
      }
      let scp=document.createElement('svg');
      scp.setAttribute('id','scp');
      scp.setAttribute('width',n*w);
      scp.setAttribute('height',n*w);
      scp.setAttribute('viewBox','0 '+(mode*tu*w)+' '+n*w+' '+n*w);

      for(let u=0;u<2;u++)
      for(e=0;e<ppn[u]*ppn[u]*n/4;e++)
      for(i=-1;i<2;i++)
         {
         let y=u?-Math.floor((Math.sqrt(n*e)-0.5)/n)*n:-Math.floor((n-Math.sqrt(n*e)-0.5)/n)*n;
         re=document.createElement('path');
         if(u)
            re.setAttribute('d','M 0,'+(Math.sqrt(n*e)-0.5+i*n+y)*w+' Q '+(Math.sqrt(n*n*e*(e+1))-n*e)*w+','+((Math.sqrt(n*e)+Math.sqrt(n*(e+1)))/2-0.5+i*n+y)*w+' '+n*w+','+(Math.sqrt(n*(e+1))-0.5+i*n+y)*w);        
         else
            re.setAttribute('d','M 0,'+(n-Math.sqrt(n*e)-0.5+i*n+y)*w+' Q '+(Math.sqrt(n*n*e*(e+1))-n*e)*w+','+(n-(Math.sqrt(n*e)+Math.sqrt(n*(e+1)))/2-0.5+i*n+y)*w+' '+n*w+','+(n-Math.sqrt(n*(e+1))-0.5+i*n+y)*w);        
         re.setAttribute('stroke','black');
         re.setAttribute('stroke-width','2');
         re.setAttribute('stroke-dasharray','16 8');
         re.setAttribute('fill','none'); 
         scp.appendChild(re);
         }
      

      
      g.appendChild(scp);
      }
      else if(graph==2)
         {addgraph(s,n,w,fsize,0);
         addgraph(s,n,w,fsize,1);
         addgraph(s,n,w,fsize,2);
         }
      else if(graph==3)
      	{
      	addfn3(n);
         addgraph(s,n,w,fsize,3);
         addgraph(s,n,w,fsize,4);
         addgraph(s,n,w,fsize,5);
      	}
      else if(graph==5)
      	{
      	addfn6(n,1);
         addgraph(s,n,w,fsize,9);
         addgraph(s,n,w,fsize,10);
         addgraph(s,n,w,fsize,11);
      	}
      else if(graph==6)
      	{
      	addfn6(n,2);
         addgraph(s,n,w,fsize,12);
         addgraph(s,n,w,fsize,13);
         addgraph(s,n,w,fsize,14);
      	}
      else if(graph==7)
      	{
      	addfn6(n,3);
         addgraph(s,n,w,fsize,15);
         addgraph(s,n,w,fsize,16);
         addgraph(s,n,w,fsize,17);
      	}
      else if(graph==8)
      	{
      	addfn6(n,4);
         addgraph(s,n,w,fsize,18);
         addgraph(s,n,w,fsize,19);
         addgraph(s,n,w,fsize,20);
      	}
      else if(graph==9)
      	{
      	addfn6(n,5);
         addgraph(s,n,w,fsize,21);
         addgraph(s,n,w,fsize,22);
         addgraph(s,n,w,fsize,23);
      	}
      s.appendChild(g);
      }
      else
         {addfn4(n);
         addgraph(s,n,w,fsize,6);
         }
         
      let grid=document.createElement('g');
      grid.setAttribute('id','grid');
      grid.setAttribute('opacity',vgrid?1:0);
      for(let e=0;e<=n;e++)
      {let li=document.createElement('line');
      li.setAttribute('id','v'+e);
      li.setAttribute('x1',w*e+(e?-0.5:0.5));
      li.setAttribute('y1',0);
      li.setAttribute('x2',w*e+(e?-0.5:0.5));
      li.setAttribute('y2',w*n);
      li.setAttribute('stroke','black');
      if(e&&e<n)
         grid.appendChild(li);
      else
         s.appendChild(li);
      
      li=document.createElement('line');
      li.setAttribute('id','h'+e);
      li.setAttribute('x1',0);
      li.setAttribute('y1',w*e+(e?-0.5:0.5));
      li.setAttribute('x2',w*n);
      li.setAttribute('y2',w*e+(e?-0.5:0.5));
      li.setAttribute('stroke','black');
      if(e&&e<n)
         grid.appendChild(li);
      else
         s.appendChild(li);}
      s.appendChild(grid);
      
      for(let e=0;e<n;e++)
      {let t=document.createElement('text');
      t.setAttribute('id','x'+e);
      t.setAttribute('x',(e+0.5)*w);
      t.setAttribute('y',n*w+fsize+1);
      t.setAttribute('font-size',fsize+'px');
      t.setAttribute('text-anchor','middle');
      t.innerHTML=e+(graph>1?1:0);
      s.appendChild(t);

      t=document.createElement('text');
      t.setAttribute('id','y'+e);
      t.setAttribute('x',n*w+7);
      t.setAttribute('y',(e+0.6)*w);
      t.setAttribute('font-size',fsize+'px');
      t.innerHTML=n-e-(graph==4?0:1)-(graph==1?mode*tu:graph==3||graph==5||graph==6||graph==7||graph==8||graph==9?tu:0);
      s.appendChild(t);
      
      if(graph==1)
      {t=document.createElement('text');
      t.setAttribute('id','t'+e);
      t.setAttribute('x',(e+0.5)*w);
      t.setAttribute('y',(n+maxc-car[e]+to-0.5)*w+fsize-1);
      t.setAttribute('font-size',fsize+'px');
      t.setAttribute('text-anchor','middle');
      t.innerHTML=car[e];
      s.appendChild(t);
      }
      }
      
      d.appendChild(s);
t.appendChild(d);
listc.appendChild(t); 

listc.innerHTML+='<span id="sc1"><br/><br/><br/><br/>Graphs: <i id="gr1"><b><big> 1 </big></b></i> <i id="gr2"><b><big> 2 </big></b></i> <i id="gr3"><b><big> 3 </big></b></i> <i id="gr4"><b><big> 4 </big></b></i> <i id="gr5"><b><big> 1D </big></b>(5)</i> <i id="gr6"><b><big> 2D </big></b>(6)</i> <i id="gr7"><b><big> 3D </big></b>(7)</i> <i id="gr8"><b><big> 4D </big></b>(8)</i> <i id="gr9"><b><big> 5D </big></b>(9)</i> <i style="padding:0;outline:none;cursor:text;"><small>(use "1", "2", "3", "4", "5", "6", "7", "8", "9" keys)</small></i><br/><br/><br/><br/> <i id="removetables100"><b>N - 100</b></i>        <i id="removetables10"><b>N - 10</b></i>        <i id="removetable"><b>N - 1</b> <small>(use "Backspace" key)</small></i>        <i id="addtable"><b>N + 1</b> <small>(use "Space" key)</small></i>        <i id="addtables"><b>N + 10</b> <small>(use "Enter" key)</small></i>        <i id="addtables100"><b>N + 100</b></i><br/><br/><br/><br/><span'+(graph==1?'':' hidden')+'> <i id="decpos"><b>- positive branch</b> <small>(use "O" key)</small></i>        <i id="incpos"><b>+ positive branch</b> <small>(use "P" key)</small></i>        <i id="decneg"><b>- negative branch</b> <small>(use "K" key)</small></i>        <i id="incneg"><b>+ negative branch</b> <small>(use "L" key)</small></i><br/><br/><br/><br/></span> <i id="switchmode"'+(swh?' hidden':'')+'>Switch (0, N) and (- N / 2, N / 2) modes <small>(use "M" key)</small></i>'+(swh?'':'        ')+'<i id="showhidegrid">Show / hide grid <small>(use "G" key)</small></i><br/><br/><br/></span>';
let sc1=document.getElementById('sc1');

if(graph>4)
   {
   s=document.createElement('select');
   s.setAttribute('onchange','cms(event)');
   let op=document.createElement('option');
   for(e=0;e<=Math.max(ms,n);e++)
      {
      op=document.createElement('option');
      op.innerHTML=e;
      if(ms==e)
         op.setAttribute('selected','selected');
      s.appendChild(op);
      }
   sc1.innerHTML+='Mass square: ';
   sc1.appendChild(s);
   
   }sc1.innerHTML+='<br/><br/>';

if(graph==7)
   {
   s=document.createElement('select');
   s.setAttribute('onchange','cf(event)');
   let op=document.createElement('option');
   op.innerHTML='Fixed width, N alters';
   if(!wmode)
      op.setAttribute('selected','selected');
   s.appendChild(op);
   op=document.createElement('option');
   op.innerHTML='Fixed period, N alters';
   if(wmode==1)
      op.setAttribute('selected','selected');
   s.appendChild(op);
   op=document.createElement('option');
   op.innerHTML='Fixed N, width alters';
   if(wmode==2)
      op.setAttribute('selected','selected');
   s.appendChild(op);
   sc1.innerHTML+='Graph mode: ';
   sc1.appendChild(s);
   
   if(wmode<2)
      {
      s=document.createElement('select');
      s.setAttribute('onchange','cw(event)');
      op=document.createElement('option');
      op.innerHTML='N';
      if(!pwidth)
         op.setAttribute('selected','selected');
      s.appendChild(op);
      for(e=1;e<=n;e++)
         {
         op=document.createElement('option');
         op.innerHTML=e;
         if(pwidth==e)
            op.setAttribute('selected','selected');
         s.appendChild(op);
         }
      sc1.innerHTML+=wmode?'   Period: ':'   Width: ';
      sc1.appendChild(s);
      }
   }
sc1.innerHTML+='<br/><br/><br/><br/><br/>';
if(graph==2)
   {
   for(e=1;e<=n;e++)
   if(fn[8][e])
      sc1.innerHTML+=e+' = '+fn[8][e]+'<br/>';
   }
document.getElementById('gr'+graph).style.background='#c0fac0';
}

function cw(e)
{
pwidth=e.target.selectedIndex;
let sct=listc.scrollTop;
addtable(nextn);
listc.scrollTop=sct;
}

function cf(e)
{
wmode=e.target.selectedIndex;
let sct=listc.scrollTop;
addtable(nextn);
listc.scrollTop=sct;
}

function cms(e)
{
ms=e.target.selectedIndex;
fnw=[[[]],[[]],[[]]];
fnwold=[[[]],[[]],[[]]];
for(let e=9;e<=23;e++)
   {fn[e]=[-1000000];
   fnold[e]=[-1000000];
   }
let sct=listc.scrollTop;
addtable(nextn);
listc.scrollTop=sct;
}


document.addEventListener('keydown',function(e){
if(!e.ctrlKey){
let c=e.code;
if(c=='Space'){
   let sct=listc.scrollTop;
   nextn++;
   addtable(nextn);
   listc.scrollTop=sct;
   }
if(c=='Backspace'){
   if(nextn>2)
      {let sct=listc.scrollTop;
      nextn--;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Enter')
   {
   let sct=listc.scrollTop;
   nextn+=10;
   addtable(nextn);
   listc.scrollTop=sct;
   }
else if(c=='KeyM')
   {
   if(graph==1)
   {mode=1-mode;
   let re=document.getElementById('scp');
   re.setAttribute('viewBox','0 '+(mode*tu*w)+' '+nextn*w+' '+nextn*w);
   for(let n=nextn;n<=nextn;n++)
      {for(let e=0;e<n;e++)
         {
         re=document.getElementById('r'+e);
         re.setAttribute('y',((n*2-e-1-mode*tu)%n)*w);
         let t=document.getElementById('y'+e);
         t.innerHTML=n-e-1-mode*tu;
         re=document.getElementById('zerostring');
         re.setAttribute('y',((n-1-mode*tu)%n)*w);
         }
      }
   }
   }
else if(c=='KeyO')
   {
   if(ppn[0])
      {
      ppn[0]--;
      addtable(nextn);
      }
   }
else if(c=='KeyP')
   {
   ppn[0]++;
   addtable(nextn);
   }
else if(c=='KeyK')
   {
   if(ppn[1])
      {
      ppn[1]--;
      addtable(nextn);
      }
   }
else if(c=='KeyL')
   {
   ppn[1]++;
   addtable(nextn);
   }
else if(c=='Digit1')
   {if(graph!=1)
      {let sct=listc.scrollTop;
      graph=1;
      swh=false;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit2')
   {if(graph!=2)
      {let sct=listc.scrollTop;
      graph=2;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit3')
   {if(graph!=3)
      {let sct=listc.scrollTop;
      graph=3;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit4')
   {if(graph!=4)
      {let sct=listc.scrollTop;
      graph=4;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit5')
   {if(graph!=5)
      {let sct=listc.scrollTop;
      graph=5;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit6')
   {if(graph!=6)
      {let sct=listc.scrollTop;
      graph=6;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit7')
   {if(graph!=7)
      {let sct=listc.scrollTop;
      graph=7;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit8')
   {if(graph!=8)
      {let sct=listc.scrollTop;
      graph=8;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='Digit9')
   {if(graph!=9)
      {let sct=listc.scrollTop;
      graph=9;
      swh=true;
      addtable(nextn);
      listc.scrollTop=sct;
      }
   }
else if(c=='KeyG')
   {
   vgrid=!vgrid;
   document.getElementById('grid').setAttribute('opacity',vgrid?1:0);
   }
}
gm=-1;
mousetextupdate(mousex,mousey);
}
);

listc.onclick=function(e){
let c=e.target;
while(c.tagName=='B'||c.tagName=='SMALL'||c.tagName=='BIG')
   c=c.parentNode;
if(c.id=='addtable')
   {nextn++;
   addtable(nextn);
   listc.scrollTop=listc.scrollHeight;
   }
   else if(c.id=='addtables')
   {
   /*for(let e=0;e<10;e++)
      {nextn++;
      addtable(nextn);
      }*/
   nextn+=10;
   addtable(nextn);
   listc.scrollTop=listc.scrollHeight;
   }
   else if(c.id=='addtables100')
   {
   nextn+=100;
   addtable(nextn);
   listc.scrollTop=listc.scrollHeight;
   }
   else if(c.id=='removetable')
   {
   if(nextn>2)
      {nextn--;
      addtable(nextn);
      listc.scrollTop=listc.scrollHeight;
      }
   }
   else if(c.id=='removetables10')
   {
   nextn-=10;
   if(nextn<2)nextn=2;
   addtable(nextn);
   listc.scrollTop=listc.scrollHeight;
   }
   else if(c.id=='removetables100')
   {
   nextn-=100;
   if(nextn<2)nextn=2;
   addtable(nextn);
   listc.scrollTop=listc.scrollHeight;
   }
   else if(c.id=='switchmode')
      {if(graph==1)
      {mode=1-mode;
      let re=document.getElementById('scp');
      re.setAttribute('viewBox','0 '+(mode*tu*w)+' '+nextn*w+' '+nextn*w);
      for(let n=nextn;n<=nextn;n++)
         {for(let e=0;e<n;e++)
            {
            re=document.getElementById('r'+e);
            re.setAttribute('y',((n*2-e-1-mode*tu)%n)*w);
            let t=document.getElementById('y'+e);
            t.innerHTML=n-e-1-mode*tu;
            re=document.getElementById('zerostring');
            re.setAttribute('y',((n-1-mode*tu)%n)*w);
            }
         }
      listc.scrollTop=listc.scrollHeight;
      }
      }
   else if(c.id=='decpos')
      {
      if(ppn[0])
         {
         ppn[0]--;
         addtable(nextn);
         }
      }
   else if(c.id=='incpos')
      {
      ppn[0]++;
      addtable(nextn);
      }
   else if(c.id=='decneg')
      {
      if(ppn[1])
         {
         ppn[1]--;
         addtable(nextn);
         }
      }
   else if(c.id=='incneg')
      {
      ppn[1]++;
      addtable(nextn);
      }
   else if(c.id=='gr1')
      {if(graph!=1)
         {graph=1;
         swh=false;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr2')
      {if(graph!=2)
         {graph=2;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr3')
      {if(graph!=3)
         {graph=3;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr4')
      {if(graph!=4)
         {graph=4;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr5')
      {if(graph!=5)
         {graph=5;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr6')
      {if(graph!=6)
         {graph=6;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr7')
      {if(graph!=7)
         {graph=7;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr8')
      {if(graph!=8)
         {graph=8;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='gr9')
      {if(graph!=9)
         {graph=9;
         swh=true;
         addtable(nextn);
         listc.scrollTop=listc.scrollHeight;
         }
      }
   else if(c.id=='showhidegrid')
      {
      vgrid=!vgrid;
      document.getElementById('grid').setAttribute('opacity',vgrid?1:0);
      }
   else if(c.tagName!='SELECT'&&c.tagName!='OPTION')
      {
      if(xshn)
         {//xsh=false;
         xshn=false;}
      else
      {let b=false;
      let y=Math.floor((mousey+listc.scrollTop-68)/w);
      if(y>=nextn||y<0)
         {y=-1000000;
         if(xsh)
            b=true;}
      let x=Math.floor((mousex+listc.scrollLeft-10)/w);
      if(x>=nextn||x<0)
         {x=-1000000;
         b=true;}
      if(!b)
         xsh=!xsh;
      /*if(xshn)
         {xsh=false;
         xshn=false;}*/
      mousetextupdate(mousex,mousey);}
      }
}


window.onkeydown = function(e) { 
  return !((e.keyCode==32) && e.target == document.body);
};


function check(n)
{let c=[];
let e;
for(e=0;e<n;e++)
   c.push(0);
let i=0;
e=0;
while(e<n&&c[i]<3)
   {i=e*e%n;
   c[i]++;
   e++;
   }
return e==n;
}

function check1(n)
{let e=2;
let a=Math.sqrt(n);
while(n%e&&e<=a)
   e++;
return e>a;
}

function check2(n)
{//if(!(n%2))
//   n/=2;
let n1=n%2?n:n/2;
let e=2;
let a=Math.sqrt(n1);
while(n1%e&&e<=a)
   e++;
return (e>a);

return (e>a!=(fn[0][n]==2&&fn[2][n]==1));
}

function addfn1(n)
{while(fn[7].length<=n)
   fn[7].push(fn[7].length*fn[7].length);
}

function addfn2(n)
{
while(fn[0].length<=n)
   {let l=fn[0].length;
   setar(l);
   fn[0].push(maxc);
   fn[1].push(maxcz);
   fn[2].push(car[0]);
   }
}

function addfn3(n)
{while(fn[3].length<=n)
   {let l=fn[3].length;
   setar(l);
   let aar=[];
   let e;
   for(e=0;e<l;e++)
      aar.push(-1);
   for(e=0;e<l;e++)
   //   if(car[tar[e]]>1&&aar[tar[e]]<0)
   if(aar[tar[e]]<0)
         aar[tar[e]]=e;
   let i=0;
   for(e of aar)if(e>0){i+=e;i%=l}
   let u=i;
   fn[3].push(u>=l/2?u-l:u);
   u=Math.floor(l/2);
   i=u*(u+1)/2;
   u=i%l;
   u=u>=l/2?u-l:u;
   fn[5].push(u);
   if(!(l%2))
      {i-=l/2;
      u=i%l;
      fn[4].push(u>=l/2?u-l:u);
      }
   else
      fn[4].push(u);
   }
}

function addfn4(n)
{while(fn[6].length<=n)
   {let l=fn[6].length;
   setar(l);
   let i=0;
   for(let e of car)if(e)i++;
   fn[6].push(i);
   }
}

function addfn5(n)
{while(fn[8].length<=n)
   {let l=fn[8].length;
   let i='';
   //if(check2(l))
   if(fn[0][l]==2&&fn[2][l]==1)
      if(l<3||l%2)
         i=l;
      else
      	i=l/2+'·2';
   fn[8].push(i);
   }
}

function addfn6old(n,d)
{while(fnold[6+3*d].length<=n)
   {let l=fnold[6+3*d].length;
   setar(l);
   let aar=[];
   let e;
   for(e=0;e<l;e++)
      aar.push([]);
   for(e=0;e<l;e++)
      aar[tar[e]].push(e);
   let iar=[[],[],[]];
   for(e=0;e<l;e++)
      {
      iar[0].push(0);
      iar[1].push(0);
      iar[2].push(0);
      }
   for(e=0;e<l;e++)
      for(let u=-1;u<aar[e].length;u++)
         if(u>=0)
            {
            if(u==0){iar[0][e]+=aar[e][0];iar[0][e]%=l}
            if(u<l/2){iar[1][e]+=aar[e][u];iar[1][e]%=l}
            if(u<=l/2){iar[2][e]+=aar[e][u];iar[2][e]%=l}
            }
   l=[l,1,1,1,1];
   for(e=1;e<5;e++)
      if(d>e)l[e]=l[0];
   //if(d==3)l[2]=Math.min(60,l[0]);
   if(d==3)
   for(e=0;e<3;e++)
      {fnwold[e].push([]);
      for(let y=0;y<=l[0];y++)
         fnwold[e][l[0]].push(0);
      }
   e=[0,0,0,0,0];
   let i=[0,0,0];
   let u;
   let s0,s1,s2,s3,s;
   for(e[0]=0;e[0]<l[0];e[0]++)
      {
      s0=tar[e[0]];
      for(e[1]=0;e[1]<l[1];e[1]++)
         {
         s1=s0+tar[e[1]];
         for(e[2]=0;e[2]<l[2];e[2]++)
            {
            s2=s1+tar[e[2]];
            for(e[3]=0;e[3]<l[3];e[3]++)
               {
               s3=s2+tar[e[3]];
               for(e[4]=0;e[4]<l[4];e[4]++)
                 {
                  //let s=(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3]+e[4]*e[4])%l[0];
                  //let s=(tar[e[0]]+tar[e[1]]+tar[e[2]]+tar[e[3]]+tar[e[4]])%l[0];
                  s=(s3+tar[e[4]])%l[0];
                  /*for(u=-1;u<aar[s].length;u++)
                  if(u>=0)
                     {
                     if(u==0){i[0]+=aar[s][0];i[0]%=l[0]}
                     if(u<l[0]/2){i[1]+=aar[s][u];i[1]%=l[0]}
                     if(u<=l[0]/2){i[2]+=aar[s][u];i[2]%=l[0]}
                     }*/
                  i[0]+=iar[0][s];i[0]%=l[0];
                  i[1]+=iar[1][s];i[1]%=l[0];
                  i[2]+=iar[2][s];i[2]%=l[0];
                  }
               }
            }
         }
      if(d==3)
         {for(let y=1;y<=l[0];y++)
            //if(!mar[y])
            //if(!e[0]%y)
            if(!mar[y]&&!e[0]%(l[0]/y))
               for(u=0;u<3;u++)
                  {fnwold[u][l[0]][y]+=i[u]-(i[u]<l[0]/2?0:l[0]);
                  fnwold[u][l[0]][y]%=l[0];
                  }
         }
      }
   /*if(d==3)
   for(u=0;u<3;u++)
   for(let y=0;y<=l[0];y++)
   if(fnw[u][l[0]][y])
       alert(fnw[u][l[0]][y]);*/
   for(u=0;u<3;u++)
      {//i[u]=i[u]%l[0];
      if(i[u]>=l[0]/2)i[u]-=l[0];
      fnold[6+3*d+u].push(i[u]);
      }
   }
}

function addfn6old2(n,d)
{

function setlat(pe,e=0)
{
for(let q=0;q<=pe;q++)
   {
   if(e)
      {
      s[e]=s[e-1];
      m[e]=m[e-1];
      mf[e]=mf[e-1];
      j[e]=1;
      if(d>e)
         {
         s[e]+=xdaar[q];
         m[e]*=caar[q];
         if((!b||e>1)&&q==pe)
            j[e]+=j[e-1];
         mf[e]*=k[e]/j[e];
         }
      }
   else
      {
      s[0]=b?tar[q]:xdaar[q];
      m[0]=b?1:caar[q];
      }
   if(e+1==d)
      {
      s[e]%=l;
      m[e]*=mf[e];
      for(u=0;u<3;u++)
         {i[u]+=iar[u][s[e]]*m[e];
         i[u]%=l;}
      }
   else if(e)
      setlat(q,e+1);
   else
   	{
   	setlat(b?caar.length-1:q,e+1);
      if(b)
         for(let y=1;y<=l;y++)
            if(!mar[y]&&!q%(l/y))
               for(u=0;u<3;u++)
                  {fnwold[u][l][y]+=i[u]-(i[u]<l/2?0:l);
                  fnwold[u][l][y]%=l;
                  }
   	}
   }
}
//addfn6old(n,d);
while(fnold[6+3*d].length<=n)
   {var l=fnold[6+3*d].length;
   setar(l);
   let aar=[];
   var e,u;
   for(e=0;e<l;e++)
      aar.push([]);
   for(e=0;e<l;e++)
      aar[tar[e]].push(e);
   var caar=[],xdaar=[],iar=[[],[],[]];
   for(e=0;e<l;e++)
      {
      if(aar[e].length)
         {
         caar.push(aar[e].length);
         xdaar.push(e);
         }
      for(u=0;u<3;u++)
         iar[u].push(0);
      }
   for(e=0;e<l;e++)
      for(let u=-1;u<aar[e].length;u++)
         if(u>=0)
            {
            if(u==0){iar[0][e]+=aar[e][0];iar[0][e]%=l}
            if(u<l/2){iar[1][e]+=aar[e][u];iar[1][e]%=l}
            if(u<=l/2){iar[2][e]+=aar[e][u];iar[2][e]%=l}
            }
   var b=d==3;
   if(b)
   for(e=0;e<3;e++)
      {fnwold[e].push([]);
      for(let y=0;y<=l;y++)
         fnwold[e][l].push(0);
      }
   var i=[0,0,0];
   var s=[0],j=[1],k=[0],m=[0],mf=[1];
   for(u=1;u<d;u++)
      {
      s.push(0);
      j.push(0);
      k.push(b?u:u+1);
      m.push(0);
      mf.push(0);
      }
   setlat((b?l:caar.length)-1);
   for(u=0;u<3;u++)
      {
      if(i[u]>=l/2)i[u]-=l;
      fnold[6+3*d+u].push(i[u]);
      //if(fn[6+3*d+u][fn[6+3*d+u].length-1]!=fnold[6+3*d+u][fn[6+3*d+u].length-1])
      //   alert('fn['+(6+3*d+u)+']['+(fn[6+3*d+u].length-1)+'] = '+fn[6+3*d+u][fn[6+3*d+u].length-1]+'\nfnold['+(6+3*d+u)+']['+(fn[6+3*d+u].length-1)+'] = '+fnold[6+3*d+u][fn[6+3*d+u].length-1]);
      //if(b)for(let y=0;y<=l;y++)
      //   if(fnw[u][l][y]!=fnwold[u][l][y])
      //      alert('fnw['+u+']['+l+']['+y+'] = '+fnw[u][l][y]+'\nfnwold['+u+']['+l+']['+y+'] = '+fnwold[u][l][y]);
      }
   }
}

// addfn6 - set lattice arrays up to N (parameters: n - N; d - number of dimensions of lattice):
// fn[9-11] - 1D
// fn[12-14] - 2D
// fn[15-17], fnw[0-2] - 3D
// fn[18-20] - 4D
// fn[21-23] - 5D
// note: lattices with higher numbers of dimensions can be written in fn, fnw using offset:
// with offset a (1+a)D lattice will be written in fn[9-11], (2+a)D in fn[12-14], (3+a)D in fn[15-17] and fnw[0-2], (4+a)D in fn[18-20], (5+a)D in fn[21-23]
function addfn6(n,d)
{

// setlat - dimension pass (parameters: pe - maximal layer of lattice, e - dimension - 1)
function setlat(pe,e=0)
{

// q - layer of lattice
for(let q=0;q<=pe;q++)
   {
   
   // not 1st pass
   if(e)
      {
      
      // add sum of squares
      s[e]=s[e-1]+xdaar[q];
      
      // multiply numbers of nodes
      m[e]=m[e-1]*caar[q];
      
      // if pattern of same coordinates continues, increase its length by 1, else set it to 1
      j[e]=(!b||e>1)&&q==pe?j[e-1]+1:1;
      
      // multiply permutation factor by number of dimensions (except 1st dimension, if 3D) and divide it by length of pattern of same coordinates
      mf[e]=mf[e-1]*k[e]/j[e];
      
      }
      
   // 1st pass
   else
      {
      
      // set square (for 3D take from tar)
      s[0]=b?tar[q]:xdaar[q];
      
      // set factor (for 3D set to 1)
      m[0]=b?1:caar[q];
      
      }
      
   // last pass
   if(e+1==d1)
      {
      
      // sum of squares mod l
      s[e]%=l;
      
      // multiply both factors
      m[e]*=mf[e];
      
      // compute elements of i1 array
      for(u=0;u<3;u++)
         {
         
         // 3D
         if(b)
         
            {
            
            // add to element of i1 array sum of roots multiplied by factor
            i1[u]+=iar[u][s[e]]*m[e];
         
            // element of i1 array mod l
            i1[u]%=l;
            
            }
            
         // not 3D
         else
         
            {
            
            // add to element of i array sum of roots multiplied by factor
            i[u]+=iar[u][s[e]]*m[e];
         
            // element of i array mod l
            i[u]%=l;
            
            }
         }
      }
      
   // not last pass
   else if(e)
   
      // if not 1st pass, invoke next pass
      setlat(q,e+1);
      
   // 1st pass
   else
   	{
   	
   	// invoke next pass (if 3D, begin to use numbers of nodes of lattice mod l)
   	setlat(b?caar.length-1:q,e+1);
   	
   	// if 3D, fill fnw array
      if(b)
         
         {
         // y - width of parallelepiped (l/y - period)
         for(let y=1;y<=l;y++)
         
            // check if period divisor of l and number of layer
            if(!mar[y]&&!q%(l/y))
            
               for(u=0;u<3;u++)
                  {
                  
                  // add to element of fnw array element of i1 array
                  fnw[u][l][y]+=i1[u];
                  
                  // element of fnw mod l
                  if(fnw[u][l][y]>=l)
                     fnw[u][l][y]%=l;
                     
                  // element of fnw ∈ (-l / 2; l / 2)
                  else if(fnw[u][l][y]>=l/2)
                     fnw[u][l][y]-=l;
                  
                  }
                  
         //
         
         for(u=0;u<3;u++)
            {
            
            // add to element of i array element of i1 array
            i[u]+=i1[u];
            
            // element of i array mod l
            i[u]%=l;
            
            }
            
         // fill ia array with zeros
         i1=[0,0,0];  
         
         }
   	}
   }
}

// invoking older version of addfn6 for comparison
//addfn6old2(n,d);

// set fn, fnw arrays up to N
while(fn[6+3*d].length<=n)

   // l - size of lattice
   {var l=fn[6+3*d].length;
   
   // set tar and mar arrays for N = l
   setar(l);
   
   // aar - array of roots (inverse tar array) (parameters: 1st - x ∈ [0; l - 1], 2nd - root number)
   let aar=[];
   
   var e,u;
   
   // fill aar with empty arrays
   for(e=0;e<l;e++)
      aar.push([]);
      
   // fill aar with roots
   for(e=0;e<l;e++)
      aar[tar[e]].push(e);
      
   // xdaar - array of sums of squares of coordinates mod l (parameter: sum number)
   // caar - array of numbers of nodes of lattice mod l such as xdaar[x] = sum of squares of coordinates mod l (parameter: x (sum number))
   // iar - array of sums of roots mod l (parameters: 1st - 0: sum of minimal roots, 1: sum of roots < l / 2, 2: sum of roots ≤ l / 2; 2nd - x ∈ [0; l - 1])
   var caar=[],xdaar=[],iar=[[],[],[]];
   
   // fill xdaar, caar arrays for 1D lattice, fill iar array with zeros
   for(e=0;e<l;e++)
      {
      if(aar[e].length)
         {
         caar.push(aar[e].length%l);
         xdaar.push(e);
         }
      for(u=0;u<3;u++)
         iar[u].push(0);
      }
      
   // fill iar array
   for(e=0;e<l;e++)
      for(let u=-1;u<aar[e].length;u++)
         if(u>=0)
            {
            if(u==0){iar[0][e]+=aar[e][0];iar[0][e]%=l}
            if(u<l/2){iar[1][e]+=aar[e][u];iar[1][e]%=l}
            if(u<=l/2){iar[2][e]+=aar[e][u];iar[2][e]%=l}
            }
            
   // b - 3D indicator (if offset is used, replace d with d + offset)
   var b=d==3;
   
   // fill xdaar, caar arrays for dD lattice (2D for 3D lattice) (if offset is used, replace d with d + offset)
   if(d>1)
      {
      
      // xdaar0, caar0 - 1D versions of xdaar, caar
      let caar0=[...caar];
      let xdaar0=[...xdaar];
      
      // e - dimension (if offset is used, replace d with d + offset)
      for(e=b?2:1;e<d;e++)
         {
         
         // aar - array of numbers of nodes of (e+1)D (2D for 3D) lattice (products of numbers mod l) such as x = sum of squares of coordinates mod l (parameter: x)
         
         // fill aar array with zeros
         for(u=0;u<l;u++)
            aar[u]=0;
            
         // fill aar array
         for(let i=0;i<caar.length;i++)
         for(u=0;u<caar0.length;u++)
            aar[(xdaar[i]+xdaar0[u])%l]+=caar[i]*caar0[u];
            
         // u - length of xdaar and caar arrays for (e+1)D (2D for 3D) lattice
         u=0;
         
         // fill xdaar, caar arrays for (e+1)D (2D for 3D) lattice
         for(let i=0;i<l;i++)
            if(aar[i])
               {
               caar[u]=aar[i]%l;
               xdaar[u]=i;
               u++;
               }
               
         // set length of xdaar and caar arrays for (e+1)D (2D for 3D) lattice
         caar.length=u;
         xdaar.length=u;
         }
      }
      
   // + mass square
   if(ms)
   for(e=0;e<caar.length;e++)
      {
      xdaar[e]+=ms;
      xdaar[e]%=l;
      }
      
   // d1 - number of dimensions for setlat function (2 for 3D, else 1)
   var d1=b?2:1;
   //var d1=d+2;
   
   // fill fnw for N = l with zeros
   if(b)
   for(e=0;e<3;e++)
      {fnw[e].push([]);
      for(let y=0;y<=l;y++)
         fnw[e][l].push(0);
      }
      
   // i - array of sums of roots (parameter: 0: sum of minimal roots, 1: sum of roots < l / 2, 2: sum of roots ≤ l / 2)
   var i=[0,0,0];
   
   // i - array of sums of roots for 1 layer of lattice (parameter: 0: sum of minimal roots, 1: sum of roots < l / 2, 2: sum of roots ≤ l / 2)
   var i1=[0,0,0];
   
   // s - array of sums of squares of coordinates mod l (parameter: dimension - 1)
   // j - array of length of pattern of equal coordinates (except 1st dimension, if 3D) (parameter: dimension - 1)
   // k - array of numbers of dimensions (except 1st dimension, if 3D) (parameter: dimension - 1)
   // m - array of factors of nodes with same sums of squares of coordinates (parameter: dimension - 1)
   // mf - array of permutation factors (parameter: dimension - 1)
   var s=[0],j=[1],k=[0],m=[0],mf=[1];
   
   // fill s, j, k, m, mf arrays (if offset is used, replace d with d + offset)
   for(u=1;u<d;u++)
      {
      s.push(0);
      j.push(0);
      k.push(b?u:u+1);
      m.push(0);
      mf.push(0);
      }
      
   // fill i, fnw arrays
   setlat((b?l:caar.length)-1);
   
   for(u=0;u<3;u++)
      {
      
      // make values of i arrays ∈ (-l / 2; l / 2)
      if(i[u]>=l/2)i[u]-=l;
      
      // fill fn arrays
      fn[6+3*d+u].push(i[u]);
      
      // comparison of fn with fnold
      /*if(fn[6+3*d+u][fn[6+3*d+u].length-1]!=fnold[6+3*d+u][fn[6+3*d+u].length-1])
         console.log('fn['+(6+3*d+u)+']['+(fn[6+3*d+u].length-1)+'] = '+fn[6+3*d+u][fn[6+3*d+u].length-1]+'\nfnold['+(6+3*d+u)+']['+(fn[6+3*d+u].length-1)+'] = '+fnold[6+3*d+u][fn[6+3*d+u].length-1]);

      // comparison of fnw with fnwold
      if(b)for(let y=0;y<=l;y++)
         if(fnw[u][l][y]!=fnwold[u][l][y])
            console.log('fnw['+u+']['+l+']['+y+'] = '+fnw[u][l][y]+'\nfnwold['+u+']['+l+']['+y+'] = '+fnwold[u][l][y]);*/
      }
   }
}

function grectclick(g){
if(!xsh)
   xshn=true;
vgr[g]=!vgr[g];
grvn[grg[g]]+=vgr[g]?1:-1;
document.getElementById('grc'+g).setAttribute('opacity',vgr[g]?1:0);
document.getElementById('gc'+g).setAttribute('opacity',vgr[g]?1:vgrh);
document.getElementById('hg'+g).setAttribute('opacity',vgr[g]?hgv:0);
}

function mousetextupdate(x,y){
   let b=false;
   let y1=Math.floor((mousey+listc.scrollTop-68)/w);
   if(y1>=nextn||y1<0)
      {y1=-1000000;
      //b=true;
      }
   document.getElementById('mh').setAttribute('y',y1*w);
   let x1=Math.floor((mousex+listc.scrollLeft-10)/w);
   if(x1>=nextn||x1<0)
      {x1=-1000000;
      b=true;}
   document.getElementById('mv').setAttribute('x',x1*w);
   
   let i=gro[graph];
   while(grg[i]==graph)
      {
      if(vgr[i])
         //document.getElementById('hg'+i).setAttribute('y',(nextn-fn[i][b?0:x1+1]-1)*w);
         document.getElementById('hg'+i).setAttribute('y',(nextn-fn[i][b?0:x1+1]-(graph==3||graph==5||graph==6||graph==7||graph==8||graph==9?tu:0)-(graph==4?0:1))*w);

         //document.getElementById('hg'+i).setAttribute('y',(fn[i][b?0:x1+1])*w);
      i++;
      }
   
   xs.hidden=(xsh||b)&&(gm<0);
   if(!xs.hidden)
      {
      let h;
      let e;
      if(gm<0)
         {
         h=x1+(graph>1?1:0);
         if(y1>=0)
            h+='; '+(nextn-y1-(graph==4?0:1)-(graph==1?mode:graph==3||graph==5||graph==6||graph==7||graph==8||graph==9?1:0)*tu);
         if(graph==1)
            {
            h+='<br/>'+car[x1]+' root'+(car[x1]==1?'':'s');
            h+='<br/>N = '+nextn;
            }
         else
         	{
         	for(e=gro[graph];e<gro[graph]+grvn1[graph];e++)
         	   {
         	   if(vgr[e])
         	      {
         	      //h+='<br/><span><svg id="sx'+e+'" width=75 height='+(maxw/3+(vgr[e+1]&&grg[e+1]==graph?10:10))+'>'+grx[e].innerHTML+'<text x="'+(maxw/2+5)+'" y="19">'+fn[e][x1+1]+'</text></svg></span>';
                  h+='<br/><span><svg id="sx'+e+'" width=75 height='+(maxw/3+(vgr[e+1]&&grg[e+1]==graph?10:10))+'>'+grx[e].innerHTML+'<text x="'+(maxw/2+5)+'" y="15">'+(graph!=7?fn[e][x1+1]:wmode>1?fnw[e-15][nextn][x1+1]:!pwidth||nextn<pwidth?fn[e][x1+1]:fnw[e-15][x1+1][wmode?(x1+1)/pwidth:pwidth])+'</text></svg></span>';

                  }
         	   }
         	}
         }
      else
         h='<i style="outline:none"><small>Click to '+(vgr[gm]?'hide':'show')+' this ghaph</small></i>';
      
      xs.innerHTML=h;
      if(gm<0&&graph>1)
      for(e=gro[graph];e<gro[graph]+grvn1[graph];e++)
      if(vgr[e])
         {
         let s=document.getElementById('sx'+e);
         s.setAttribute('width',s.getBBox().width+10);
         }
      
      
      //xs.style.left=x+(x*2<window.innerWidth?35:-xs.offsetWidth-15)+'px';
      xs.style.left=x+(x+110<window.innerWidth?35:-xs.offsetWidth-15)+'px';
      //xs.style.top=y-(y*2<window.innerHeight?5:xs.offsetHeight-30)+'px';
      xs.style.top=y-5+'px';
      }
}

document.onmousemove=function(e){
   mousex=e.clientX;
   mousey=e.clientY;
   //console.log(mousey);
   mousetextupdate(mousex,mousey);
}

document.onmouseleave=function(e){
   mousex=-1000000;
   mousey=-1000000;
   //xs.hidden=true;
   mousetextupdate(mousex,mousey);
}

listc.onscroll=function(e){
   mousetextupdate(mousex,mousey);
}

let isDown = false;
let startX,startY;
let scrollLeft,scrollTop;

listc.addEventListener('mousedown', (e) => {
  isDown = true;
  listc.classList.add('active');
  startX = e.pageX - listc.offsetLeft;
  startY = e.pageY - listc.offsetTop;
  scrollLeft = listc.scrollLeft;
  scrollTop = listc.scrollTop;
});

listc.addEventListener('mouseup', () => {
  isDown = false;
  listc.classList.remove('active');
});

listc.addEventListener('mousemove', (e) => {
  if(!isDown) return;
  e.preventDefault();
  const x = e.pageX - listc.offsetLeft;
  const y = e.pageY - listc.offsetTop;
  const walkX = (x - startX) * 1; //scroll-fast
  const walkY = (y - startY) * 1;
  listc.scrollLeft = scrollLeft - walkX;
  listc.scrollTop = scrollTop - walkY;
  //if(scrollLeft!=listc.scrollLeft||scrollTop!=listc.scrollTop)
     xshn=true;
});


// mode - 0: (0; N), 1: (- N / 2, N / 2) for graph=1
let mode=0;  

// nextn - N                       
let nextn=2;    
                    
// tar - array of x*x mod N (parameter - x ∈ [0; N - 1])
// car - array of numbers of roots of x (parameter - x ∈ [0; N - 1])
// maxc - maximal value of car array
// maxcz - maximal value of car array except car[0]
// mar - array of N mod x (mar[0] = 0) (parameter - x ∈ [0; N - 1])
let tar,car,maxc,maxcz,mar;

// fnumber - maximal parameter values of fn array
let fnumber=23;

// fn[0] - array of maximal multiplicities (parameter - N)
// fn[1] - array of maximal multiplicities except zero (parameter - N)
// fn[2] - array of multiplicities of zero (parameter - N)
// fn[3] - array of sums of minimal roots (parameter - N)
// fn[4] - array of sums of roots < N / 2 (parameter - N)
// fn[5] - array of sums of roots ≤ N / 2 (parameter - N)
// fn[6] - array of numbers of x ∈ [0; N - 1]: ∃ √x (parameter - N)
// fn[7] - array of N*N (parameter - N)
// fn[8] - array of factorizations of prime and doubled prime N (empty string for other N) (parameter - N)
// fn[9] - array of sums of minimal roots for squares of coordinates of nodes of 1D N lattice (parameter - N)
// fn[10] - array of sums of roots < N / 2 for squares of coordinates of nodes of 1D N lattice (parameter - N)
// fn[11] - array of sums of roots ≤ N / 2 for squares of coordinates of nodes of 1D N lattice (parameter - N)
// fn[12] - array of sums of minimal roots for squares of coordinates of nodes of 2D N x N lattice (parameter - N)
// fn[13] - array of sums of roots < N / 2 for squares of coordinates of nodes of 2D N x N lattice (parameter - N)
// fn[14] - array of sums of roots ≤ N / 2 for squares of coordinates of nodes of 2D N x N lattice (parameter - N)
// fn[15] - array of sums of minimal roots for squares of coordinates of nodes of 3D N x N x N lattice (parameter - N)
// fn[16] - array of sums of roots < N / 2 for squares of coordinates of nodes of 3D N x N x N lattice (parameter - N)
// fn[17] - array of sums of roots ≤ N / 2 for squares of coordinates of nodes of 3D N x N x N lattice (parameter - N)
// fn[18] - array of sums of minimal roots for squares of coordinates of nodes of 4D N x N x N x N lattice (parameter - N)
// fn[19] - array of sums of roots < N / 2 for squares of coordinates of nodes of 4D N x N x N x N lattice (parameter - N)
// fn[20] - array of sums of roots ≤ N / 2 for squares of coordinates of nodes of 4D N x N x N x N lattice (parameter - N)
// fn[21] - array of sums of minimal roots for squares of coordinates of nodes of 5D N x N x N x N x N lattice (parameter - N)
// fn[22] - array of sums of roots < N / 2 for squares of coordinates of nodes of 5D N x N x N x N x N lattice (parameter - N)
// fn[23] - array of sums of roots ≤ N / 2 for squares of coordinates of nodes of 5D N x N x N x N x N lattice (parameter - N)
let fn=[];

// fnw[0] - array of sums of minimal roots for squares of coordinates of nodes of 3D width x N x N lattice (1st parameter - N, 2nd parameter - width ∈ [0; N - 1])
// fnw[1] - array of sums of roots < N / 2 for squares of coordinates of nodes of 3D width x N x N lattice (1st parameter - N, 2nd parameter - width ∈ [0; N - 1])
// fnw[2] - array of sums of roots ≤ N / 2 for squares of coordinates of nodes of 3D width x N x N lattice (1st parameter - N, 2nd parameter - width ∈ [0; N - 1])
let fnw=[[[]],[[]],[[]]];

// fnold, fnwold - copies of fn, fnw array, created by old versions of functions
let fnold=[];

let fnwold=[[[]],[[]],[[]]];
for(let e=0;e<=fnumber;e++)
   {fn.push([]);
   fnold.push([]);
   }
   
// mousex - x coordinate of mouse cursor in browser
// mousey - y coordinate of mouse cursor in browser
let mousex=-1000000;
let mousey=-1000000;

for(let e=0;e<=fnumber;e++)
   {fn[e].push(mousey);
   fnold[e].push(mousey);
   }
   
// cgr - array of colors of graphs of fn arrays (parameter - number of fn array)
let cgr=['orange','green','blue','gray','deeppink','deepskyblue','purple','','','gray','deeppink','deepskyblue','gray','deeppink','deepskyblue','gray','deeppink','deepskyblue','gray','deeppink','deepskyblue','gray','deeppink','deepskyblue'];

// wgr - array of widths of graphs of fn arrays (parameter - number of fn array)
let wgr=[5,15,15,5,10,15,5,0,0,5,10,15,5,10,15,5,10,15,5,10,15,5,10,15];

// fgr - array of tag names of marks of graphs of fn arrays (parameter - number of fn array)
let fgr=['rect','polygon','circle','rect','polygon','circle','rect','','','rect','polygon','circle','rect','polygon','circle','rect','polygon','circle','rect','polygon','circle','rect','polygon','circle'];

// tgr - array of captions of graphs of fn arrays (parameter - number of fn array)
let tgr=['max multiplicity','max multiplicity except zero','multiplicity of zero','sum of min roots','sum of roots < N / 2','sum of roots ≤ N / 2','number of x: ∃ √x','','','sum of min roots','sum of roots < N / 2','sum of roots ≤ N / 2','sum of min roots','sum of roots < N / 2','sum of roots ≤ N / 2','sum of min roots','sum of roots < N / 2','sum of roots ≤ N / 2','sum of min roots','sum of roots < N / 2','sum of roots ≤ N / 2','sum of min roots','sum of roots < N / 2','sum of roots ≤ N / 2'];

// vgr - array of visibilities of graphs of fn arrays (true - visible, false - invisible) (parameter - number of fn array)
let vgr=[]

for(let e=0;e<=fnumber;e++)
   vgr.push(true);
   
// grx - array of graphs of fn arrays (parameter - number of fn array)
let grx=new Array(fnumber);

// opacity of caption of invisible graph
let vgrh=0.15;

// mhvh - opacity of highlighted row and column
// hgv - opacity of rows of values of displayed fn arrays
let mhvh=0.15,hgv=0.025;

// tu - vertical offset factor for graphs with negative values
let tu;

// gro - array of initial numbers of fn arrays (parameter - displayed set of graphs)
let gro=[0,0,0,3,6,9,12,15,18,21];

// grg - array of displayed set of graphs (parameter - number of fn array)
let grg=[2,2,2,3,3,3,4,0,0,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9];

// grvn - array of numbers of visible graphs (parameter - displayed set of graphs)
let grvn=[0,0,3,3,1,3,3,3,3,3];

// grvn - array of numbers of graphs (parameter - displayed set of graphs)
let grvn1=[0,0,3,3,1,3,3,3,3,3];

// minw - minimal size of cell of graphs
let minw=16;

// maxw - maximal size of cell of graphs
let maxw=31;

// graph - displayed set of graphs
let graph=1;

// w - size of cell of graphs
// gm - number of caption of graph (parameter - number of fn array)
// xsh - visibility of text near mouse cursor
// xshn - indicator of click of caption of graph
// vgrid - visibility of grid
// swh - invisibility of mode switcher
// maxfsize - maximal font size of captions of rows, coumns and bar graphs
let w,gm=-1,xsh=true,xshn=false,vgrid=true,swh=false,maxfsize=16;

// pwidth - width or period of 3D lattice
// wmode - mode of graphs of 3D lattice (0: fixed width, N alters; 1: fixed period, N alters; 2: fixed N, width alters)
let pwidth=0,wmode=0;

// ppn - array of numbers of N / 2 parabolic segments (0 -  positive, 1 - negative)
let ppn=[1,1];

// ms - mass square
let ms=0;

addfn1(100);
addfn2(100);
addfn3(100);
addfn4(100);
addfn5(100);
addfn6(50,1);
addfn6(50,2);
addfn6(50,3);
addfn6(50,4);
addfn6(50,5);
 
addtable(nextn);
if(graph>1)switchmode.hidden=true;

//nextn=110;

//listc.innerHTML+='<br/><br/>';
/*addfn2(100000);
for(let e=2;e<=100000;e++)
   if(check2(e))
      listc.innerHTML+=e+'<br/>';*/




</script></body></html>
